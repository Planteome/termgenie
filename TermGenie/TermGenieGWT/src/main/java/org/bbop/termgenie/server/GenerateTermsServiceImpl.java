package org.bbop.termgenie.server;

import static org.bbop.termgenie.server.TermGenerationMessageTool.*;
import static org.bbop.termgenie.shared.ErrorMessages.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.bbop.termgenie.core.OntologyAware.Ontology;
import org.bbop.termgenie.core.OntologyAware.OntologyTerm;
import org.bbop.termgenie.core.TemplateField;
import org.bbop.termgenie.core.TemplateField.Cardinality;
import org.bbop.termgenie.core.TermTemplate;
import org.bbop.termgenie.core.rules.TermGenerationEngine;
import org.bbop.termgenie.core.rules.TermGenerationEngine.MultiValueMap;
import org.bbop.termgenie.core.rules.TermGenerationEngine.TermGenerationInput;
import org.bbop.termgenie.core.rules.TermGenerationEngine.TermGenerationOutput;
import org.bbop.termgenie.core.rules.TermGenerationEngine.TermGenerationParameters;
import org.bbop.termgenie.server.ValidateUserCredentialServiceImpl.UserCredentialValidator;
import org.bbop.termgenie.services.GenerateTermsService;
import org.bbop.termgenie.shared.GWTFieldValidator;
import org.bbop.termgenie.shared.GWTFieldValidator.GWTValidationHint;
import org.bbop.termgenie.shared.GWTGenerationResponse;
import org.bbop.termgenie.shared.GWTPair;
import org.bbop.termgenie.shared.GWTTermGenerationParameter;
import org.bbop.termgenie.shared.GWTTermGenerationParameter.GWTMultiValueMap;
import org.bbop.termgenie.shared.GWTTermGenerationParameter.GWTOntologyTerm;
import org.bbop.termgenie.shared.GWTTermTemplate;
import org.bbop.termgenie.shared.GWTTermTemplate.GWTCardinality;
import org.bbop.termgenie.shared.GWTTermTemplate.GWTTemplateField;
import org.semanticweb.owlapi.model.OWLObject;

import owltools.graph.OWLGraphWrapper;

import com.google.gwt.user.server.rpc.RemoteServiceServlet;

@SuppressWarnings("serial")
public class GenerateTermsServiceImpl extends RemoteServiceServlet implements GenerateTermsService {

	private static final TemplateCache TEMPLATE_CACHE = TemplateCache.getInstance();
	private static final OntologyTools ontologyTools = ImplementationFactory.getOntologyTools();
	private static final UserCredentialValidator validator = ImplementationFactory.getUserCredentialValidator();
	private static final TermGenerationEngine termGeneration = ImplementationFactory.getTermGenerationEngine();
	private static final OntologyCommitTool committer = ImplementationFactory.getOntologyCommitTool();
	
	@Override
	public GWTTermTemplate[] getAvailableGWTTermTemplates(String ontologyName) {
		// sanity check
		if (ontologyName == null) {
			// silently ignore this
			return new GWTTermTemplate[0];
		}
		Collection<TermTemplate> templates = getTermTemplates(ontologyName);
		if (templates.isEmpty()) {
			// short cut for empty results.
			return new GWTTermTemplate[0];
		}

		// encode the templates for GWT
		List<GWTTermTemplate> gwtTemplates = new ArrayList<GWTTermTemplate>();
		for (TermTemplate template : templates) {
			gwtTemplates.add(GWTTemplateTools.createGWTTermTemplate(template));
		}
		return gwtTemplates.toArray(new GWTTermTemplate[gwtTemplates.size()]);
	}

	/*
	 * Do not trust any input here. Do not assume that this is well formed, as the
	 * request could be generated by a different client!
	 */
	@Override
	public GWTGenerationResponse generateTerms(String ontologyName,
			GWTPair<GWTTermTemplate, GWTTermGenerationParameter>[] allParameters, 
			boolean commit, String username, String password) {
		// sanity checks
		if (ontologyName == null || ontologyName.isEmpty()) {
			return new GWTGenerationResponse(NO_ONTOLOGY, null, null);
		}
		if (allParameters == null) {
			return new GWTGenerationResponse(NO_TERM_GENERATION_PARAMETERS, null, null);
		}
		if (commit) {
			if (username == null || username.isEmpty()) {
				return new GWTGenerationResponse(MISSING_USERNAME, null, null);
			}
		}
		// retrieve target ontology
		Ontology ontology = ontologyTools.getOntology(ontologyName);
		if (ontology == null) {
			return new GWTGenerationResponse(NO_ONTOLOGY, null, null);
		}

		// term generation parameter validation
		List<GWTValidationHint> allErrors = new ArrayList<GWTFieldValidator.GWTValidationHint>();
		for (GWTPair<GWTTermTemplate, GWTTermGenerationParameter> pair : allParameters) {
			if (pair == null) {
				return new GWTGenerationResponse(UNEXPECTED_NULL_VALUE, null, null);
			}
			GWTTermTemplate one = pair.getOne();
			GWTTermGenerationParameter parameter = pair.getTwo();
			if (one == null || parameter == null) {
				return new GWTGenerationResponse(UNEXPECTED_NULL_VALUE, null, null);
			}
			// retrieve the template from the server, do not trust the submitted one.
			TermTemplate template = getTermTemplate(ontologyName, one.getName());
			if (template == null) {
				return new GWTGenerationResponse("Unknow template specified: " + one.getName(), null, null);
			}
			GWTTermTemplate gwtTermTemplate = GWTTemplateTools.createGWTTermTemplate(template);
			
			List<GWTValidationHint> errors = GWTFieldValidator.validateParameters(gwtTermTemplate,
					parameter);
			if (!errors.isEmpty()) {
				allErrors.addAll(errors);
			}
		}
		// return validation errors
		if (!allErrors.isEmpty()) {
			return new GWTGenerationResponse(null, allErrors, null);
		}
		if (commit) {
			// check user name and password
			// use java instance, do not do additional round trip via servlet.
			boolean valid = validateCredentials(username, password);
			if (!valid) {
				return new GWTGenerationResponse(UNKOWN_USERNAME_PASSWORD, null, null);
			}
		}
		// generate term candidates
		List<TermGenerationInput> generationTasks = createGenerationTasks(ontologyName, allParameters);
		List<TermGenerationOutput> candidates = generateTermsInternal(ontology, generationTasks);

		// validate candidates (or is this done during the generation?)
		if (candidates == null || candidates.isEmpty()) {
			return new GWTGenerationResponse(NO_TERMS_GENERATED, null, null);
		}
		
		List<String> messages = new ArrayList<String>(candidates.size());
		
		// commit if required
		if (commit) {
			boolean success = executeCommit(ontology, candidates);
			throw new RuntimeException("Not implemented");
			// TODO generate result for a commit (success or error)? status?
		}
		else {
			for(TermGenerationOutput candidate : candidates) {
				messages.add(generateTermValidationMessage(candidate));
			}
		}
		GWTGenerationResponse generationResponse = new GWTGenerationResponse(null, null, messages);
		// return response
		return generationResponse;
	}

	private List<TermGenerationInput> createGenerationTasks(String ontologyName, GWTPair<GWTTermTemplate, GWTTermGenerationParameter>[] allParameters) {
		List<TermGenerationInput> result = new ArrayList<TermGenerationInput>();
		for (GWTPair<GWTTermTemplate, GWTTermGenerationParameter> gwtPair : allParameters) {
			GWTTermTemplate gwtTemplate = gwtPair.getOne();
			TermTemplate template = getTermTemplate(ontologyName, gwtTemplate.getName());
			TermGenerationParameters parameters = GWTTemplateTools.createTermGenerationParameters(gwtPair.getTwo(), gwtTemplate, template);
			TermGenerationInput input = new TermGenerationInput(template, parameters);
			result.add(input);
		}
		return result;
	}

	private Collection<TermTemplate> getTermTemplates(String ontology) {
		Collection<TermTemplate> templates;
		synchronized (TEMPLATE_CACHE) {
			templates = TEMPLATE_CACHE.getTemplates(ontology);
			if (templates == null) {
				templates = requestTemplates(ontology);
				TEMPLATE_CACHE.put(ontology, templates);
			}
		}
		return templates;
	}

	private TermTemplate getTermTemplate(String ontology, String name) {
		TermTemplate template;
		synchronized (TEMPLATE_CACHE) {
			template = TEMPLATE_CACHE.getTemplate(ontology, name);
			if (template == null) {
				Collection<TermTemplate> templates = TEMPLATE_CACHE.getTemplates(ontology);
				if (templates == null) {
					templates = requestTemplates(ontology);
					TEMPLATE_CACHE.put(ontology, templates);
				}
				template = TEMPLATE_CACHE.getTemplate(ontology, name);
			}
		}
		return template;
	}

	/**
	 * Request the templates for a given ontology.
	 * 
	 * @param ontology
	 * @return templates, never null
	 */
	protected Collection<TermTemplate> requestTemplates(String ontology) {
		List<TermTemplate> templates = ontologyTools.getTermTemplates(ontology);
		if (templates == null) {
			templates = Collections.emptyList();
		}
		return templates;
	}

	protected boolean validateCredentials(String username, String password) {
		return validator.validate(username, password);
	}

	protected List<TermGenerationOutput> generateTermsInternal(Ontology ontology, List<TermGenerationInput> generationTasks) {
		return termGeneration.generateTerms(ontology, generationTasks); 
	}

	protected boolean executeCommit(Ontology ontology, List<TermGenerationOutput> candidates) {
		return committer.commitCandidates(ontology, candidates);
	}

	/**
	 * Tools for converting a term generation details into the GWT specific
	 * (transfer) formats.
	 */
	static class GWTTemplateTools {

		/**
		 * Convert a single template into a GWT specific data structure.
		 * 
		 * @param template
		 * @return internal format
		 */
		static GWTTermTemplate createGWTTermTemplate(TermTemplate template) {
			GWTTermTemplate gwtTermTemplate = new GWTTermTemplate();
			gwtTermTemplate.setName(template.getName());
			List<TemplateField> fields = template.getFields();
			int size = fields.size();
			GWTTemplateField[] gwtFields = new GWTTemplateField[size];
			for (int i = 0; i < size; i++) {
				gwtFields[i] = createGWTTemplateField(fields.get(i));
			}
			gwtTermTemplate.setFields(gwtFields);
			return gwtTermTemplate;
		}

		private static GWTTemplateField createGWTTemplateField(TemplateField field) {
			GWTTemplateField gwtField = new GWTTemplateField();
			gwtField.setName(field.getName());
			gwtField.setRequired(field.isRequired());
			Cardinality c = field.getCardinality();
			gwtField.setCardinality(new GWTCardinality(c.getMinimum(), c.getMaximum()));
			gwtField.setFunctionalPrefixes(field.getFunctionalPrefixes().toArray(new String[0]));
			if (field.hasCorrespondingOntologies()) {
				List<Ontology> ontologies = field.getCorrespondingOntologies();
				String[] ontologyNames = new String[ontologies.size()];
				for (int i = 0; i < ontologyNames.length; i++) {
					Ontology ontology = ontologies.get(i);
					ontologyNames[i] = ontologyTools.getOntologyName(ontology);
				}
				gwtField.setOntologies(ontologyNames);
			}
			return gwtField;
		}
		
		static TermGenerationParameters createTermGenerationParameters(GWTTermGenerationParameter gwt, GWTTermTemplate gwtTemplate, TermTemplate template) {
			TermGenerationParameters result = new TermGenerationParameters();
			GWTTemplateField[] gwtFields = gwtTemplate.getFields();
			for (GWTTemplateField gwtField : gwtFields) {
				TemplateField field = template.getField(gwtField.getName());
				copyAll(gwt, result, gwtField, field);
			}
			return result;
		}
		
		private static void copyAll(GWTTermGenerationParameter gwt, TermGenerationParameters target, GWTTemplateField gwtKey, TemplateField key) {
			copy(gwt.getPrefixes(), target.getPrefixes(), gwtKey, key);
			copy(gwt.getStrings(), target.getStrings(), gwtKey, key);
			copyConvert(gwt.getTerms(), target.getTerms(), gwtKey, key);
		}
		
		private static void copyConvert(GWTMultiValueMap<GWTOntologyTerm> gwt, MultiValueMap<OntologyTerm> target, GWTTemplateField gwtKey, TemplateField key) {
			int count = gwt.getCount(gwtKey);
			if (count > 0) {
				for (int i = 0; i < count; i++) {
					GWTOntologyTerm gwtOntologyTerm = gwt.getValue(gwtKey, i);
					OntologyTerm value = getOntologyTerm(gwtOntologyTerm);
					target.addValue(value, key, i);
				}
			}
		}

		private static OntologyTerm getOntologyTerm(GWTOntologyTerm gwtOntologyTerm) {
			String ontologyName = gwtOntologyTerm.getOntology();
			Ontology ontology = ontologyTools.getOntology(ontologyName);
			
			String id = gwtOntologyTerm.getTermId();
			String label = null;
			String definition = null;
			Set<String> synonyms = null;
			String cdef = null;
			
			OWLGraphWrapper realInstance = ontology.getRealInstance();
			if (realInstance != null) {
				OWLObject owlObject = realInstance.getOWLObjectByIdentifier(id);
				if (owlObject != null) {
					label = realInstance.getLabel(owlObject);
					definition = realInstance.getDef(owlObject);
//					synonyms = realInstance.getSynonymStrings(owlObject);
					// TODO replace this with a proper implementation
				}
			}
			
			return new OntologyTerm.DefaultOntologyTerm(id, label, definition, synonyms, cdef); 
		}

		private static <T> void copy(GWTMultiValueMap<T> gwt, MultiValueMap<T> target, GWTTemplateField gwtKey, TemplateField key) {
			int count = gwt.getCount(gwtKey);
			if (count > 0) {
				for (int i = 0; i < count; i++) {
					target.addValue(gwt.getValue(gwtKey, i), key, i);
				}
			}
		}
	}

	static class TemplateCache {
		private static volatile TemplateCache instance = null;
		private final Map<String, Map<String, TermTemplate>> templates;

		private TemplateCache() {
			templates = new HashMap<String, Map<String, TermTemplate>>();
		}

		public synchronized static TemplateCache getInstance() {
			if (instance == null) {
				instance = new TemplateCache();
			}
			return instance;
		}

		void put(String ontology, Collection<TermTemplate> templates) {
			Map<String, TermTemplate> namedValues = new HashMap<String, TermTemplate>();
			for (TermTemplate template : templates) {
				namedValues.put(template.getName(), template);
			}
			if (namedValues.isEmpty()) {
				namedValues = Collections.emptyMap();
			}
			this.templates.put(ontology, namedValues);
		}

		boolean hasOntology(String ontology) {
			return templates.containsKey(ontology);
		}

		Collection<TermTemplate> getTemplates(String ontology) {
			Map<String, TermTemplate> namedValues = templates.get(ontology);
			if (namedValues == null) {
				return null;
			}
			return namedValues.values();
		}

		TermTemplate getTemplate(String ontology, String templateName) {
			Map<String, TermTemplate> namedValues = templates.get(ontology);
			if (namedValues == null) {
				return null;
			}
			return namedValues.get(templateName);
		}
	}
}
